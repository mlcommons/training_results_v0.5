# Copyright 2018 Google. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ==============================================================================
"""Util functions for running Mask RCNN model using TPU low level APIs.
"""

import tensorflow as tf


def wrap_computation_in_while_loop(op_fn, n, parallel_iterations=1):
  """Wraps the ops generated by `op_fn` in tf.while_loop."""

  def computation(i):
    ops = op_fn()
    if not isinstance(ops, list):
      ops = [ops]
    with tf.control_dependencies(ops):
      return i + 1

  return tf.while_loop(
      lambda i: tf.less(i, n),
      computation, [tf.constant(0)],
      parallel_iterations=parallel_iterations)


class InputsFlattener(object):
  """Restores the flattened inputs to original features and labels form.

  Args:
    flattened_inputs: Flattened inputs for each shard.

  Returns:
    A tuple of (`features`, `labels`), where `labels` could be None.
  """

  def __init__(self):
    self._feature_structure = {}

  def flatten_features_and_labels(self, features, labels):
    """Flattens the `features` and `labels` to a single tensor list."""
    self._feature_structure['features'] = features
    if labels is not None:
      self._feature_structure['labels'] = labels
    return tf.contrib.framework.nest.flatten(self._feature_structure)

  def unflatten_features_and_labels(self, flattened_inputs):
    unflattened_inputs = tf.contrib.framework.nest.pack_sequence_as(
        self._feature_structure, flattened_inputs)
    return unflattened_inputs['features'], unflattened_inputs.get('labels')


class CapturedObject(object):
  """A placeholder to capture an object.

  This is useful when we need to capture a Python object in the Tensorflow
  control flow body function and use it outside the control flow.
  """

  def __init__(self):
    self._object = None
    self._captured = False

  def capture(self, o):
    self._captured = True
    self._object = o

  def get(self):
    if not self._captured:
      raise RuntimeError(
          'InternalError: Object is not captured properly before `get`. '
          'Please file bug.')
    return self._object
